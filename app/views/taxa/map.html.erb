<%- content_for(:title) do -%>
  <%- @title = capture do %>
    Map for <%= link_to @taxon.name, @taxon %>
  <%- end -%>
  <%= strip_tags(@title) %>
<%- end -%>

<%- content_for(:extrajs) do -%>
  <%= javascript_include_tag "polymaps.min", "polymaps.extra", "polymaps.kml", "jquery/plugins/jquery.qtip2.min", "d3.min" %>
  <script type="text/javascript" charset="utf-8">
    var TILESTACHE_SERVER = <%= INAT_CONFIG['tile_servers']['tilestache'].inspect %>
    var countyListings = <%= @county_listings.to_json %>;
    var stateListings = <%= @state_listings.to_json %>;
    var countryListings = <%= @country_listings.to_json %>;
    var extent = <%= @extent.to_json %>;
    var taxonRangeUrl = <%= (@taxon_range ? taxon_range_geom_url(@taxon, :format => "geojson") : nil).to_json %>
    var children = <%= @children.to_json %>
    window.colorScale = d3.scale.category10()
    function classifyCounties(e) { classifyPlaces(e, {placeType: 'county'}) }
    function classifyStates(e) { classifyPlaces(e, {placeType: 'state'}) }
    function classifyCountries(e) { classifyPlaces(e, {placeType: 'country'}) }
    function classifyPlaces(e, options) {
      var options = options || {},
          placeType = options.placeType || 'county'
          // visibleFeatures = []
      for (var i = e.features.length - 1; i >= 0; i--){
        var feature = e.features[i]
        if (feature.data.properties) {
          var placeId = feature.data.properties.place_id
        } else {
          continue
        }
        var listing
        switch (placeType) {
          case 'county':
            listing = countyListings[placeId]
            break;
          case 'state':
            listing = stateListings[placeId]
            break;
          case 'country':
            listing = countryListings[placeId]
            break;
        }
        if (listing) {
          feature.element.setAttribute('class', placeType + ' ' + (listing.last_observation_id ? 'confirmed' : 'putative'))
          // visibleFeatures.push(feature)
        }
      }
    }
    function handleObservations(e) {
      for (var i = e.features.length - 1; i >= 0; i--){
        var feature = e.features[i]
        if (!feature || !feature.element) {continue}
        feature.element.setAttribute('data-observation-id', feature.data.properties.observation_id || feature.data.properties.id)
        var cssClass = feature.data.properties.quality_grade
        if (feature.data.properties.quality_grade == 'research' || feature.data.properties.quality_grade == 'community') {
          cssClass += ' confirmed'
        } else {
          cssClass += ' putative'
        }
        feature.element.setAttribute('class', cssClass)
        $(feature.element).qtip({
          style: {
            classes: 'mini infowindow observations ui-tooltip-light ui-tooltip-shadow'
          },
          show: {
            event: 'click',
            solo: true
          },
          hide: {
            event: 'unfocus'
          },
          position: {
            viewport: $(window),
            my: 'bottom left',
            at: 'center center'
          },
          content: {
            text: '<span class="meta loading status">Loading..</span>',
            ajax: {
              url: '/observations/'+feature.data.properties.id,
              method: 'GET',
              data: {partial: 'cached_component'}
            }
          }
        })
      }
    }
    function handleTaxonObservations(e) {
      // if (window.extent) { return };
      // window.extent = Polymaps.bounds(e.features)
      // window.map.extent(window.extent).zoomBy(-.5);
    }
    // function legend(e) {
    //   var lyr = $(e.tile.element).parent().parent();
    //   // console.log("$(e.tile.element).parents(): ", $(e.tile.element).parents());
    //   if (lyr.length == 0) { return };
    //   // console.log("lyr: ", lyr);
    //   var klass = $(lyr).attr('id') || 'Unknown',
    //       title = klass.replace(/[-_]/, ' ');
    //   if ($('#legend .'+klass).length > 0) { return };
    //   var li = $('<li></li>').addClass(klass),
    //       symbol = $('<span></span>').addClass('symbol'),
    //       label = $('<label></label>').html(title);
    //   li.append(symbol, label)
    //   $('#legend ul').append(li)
    // }
    
    function styleRange(e, child) {
      var fill = colorScale(child.id)
      var stroke = d3.rgb(fill).darker().toString()
      for (var i = e.features.length - 1; i >= 0; i--){
        var feature = e.features[i]
        feature.element.setAttribute('fill', fill)
        feature.element.setAttribute('stroke', stroke)
      }
    }
    
    function styleObservations(e, child) {
      var fill = colorScale(child.id)
      var stroke = fill.darken()
    }
    
    function addPlaces() {
      layers['countries_simple'] = po.geoJson()
        .id('countries_simple')
        .zoom(function(z) {
          if (z > 3) { return 100};
          return z;
        })
        .url(TILESTACHE_SERVER+"/countries_simplified/{Z}/{X}/{Y}.geojson")
        .on('load', classifyCountries)
      map.add(layers['countries_simple']);

      layers['states_simple'] = po.geoJson()
        .id('states_simple')
        .zoom(function(z) {
          if (z < 4) { return -100};
          if (z > 6) { return 100};
          return z;
        })
        .url(TILESTACHE_SERVER+"/states_simplified/{Z}/{X}/{Y}.geojson")
        .on('load', classifyStates)
      map.add(layers['states_simple']);

      layers['counties_simple'] = po.geoJson()
        .id('counties_simple')
        .zoom(function(z) {
          if (z < 7) { return -100};
          if (z > 11) { return 100};
          return z;
        })
        .url(TILESTACHE_SERVER+"/counties_simplified/{Z}/{X}/{Y}.geojson")
        .on('load', classifyCounties)
      map.add(layers['counties_simple']);

      layers['counties'] = po.geoJson()
        .id('counties')
        .zoom(function(z) {
          if (z < 12) { return -100};
          if (z > 13) { return 100};
          return z;
        })
        .url(TILESTACHE_SERVER+"/counties/{Z}/{X}/{Y}.geojson")
        .on('load', classifyCounties)
      map.add(layers['counties']);
    }
    
    function addObservations() {
      layers['observations'] = po.geoJson()
        .id('observations')
        .url("<%= observations_of_url(@taxon, :format => 'geojson') %>")
        .tile(false)
        .on('load', handleObservations)
        .on('load', handleTaxonObservations)
        .clip(false)
      map.add(layers['observations']);
    }
    
    $(document).ready(function() {
      window.layers = {}
      window.po = org.polymaps
      window.map = po.map()
        .container($('#map').get(0).appendChild(po.svg('svg')))
        .zoomRange([2, 15])
        .add(po.interact());
      if (window.location.hash.length > 0) {
        // let the po.hash() control handle it
      } else if (extent) {
        map.extent(<%= @extent.to_json %>).zoomBy(-0.5)
      } else {
        map.center({lat: 0, lon: 0}).zoom(3)
      }
      // map.center({lat: 37.5, lon: -121.5}).zoom(9)
      // map.center({lat: 0, lon: 0}).zoom(2)
      
      map.add(po.hash())
      
      <% if @cloudmade_key %>
        map.add(po.image()
            .url(po.url("http://{S}tile.cloudmade.com"
            + "/<%= @cloudmade_key %>"
            + "/998/256/{Z}/{X}/{Y}.png")
            .hosts(["a.", "b.", "c.", ""])));
      <% end %>
      
      if (children && children.length > 0) {
        $('#legend ul').html('')
        // addObservations()
        var styling = po.stylist()
          .style('visibility', 'visible')
          .style('fill', function(f) { return colorScale(f.properties.taxon_id) })
          .style('stroke', function(f) { return d3.rgb(colorScale(f.properties.taxon_id)).darker().toString() })
          
        $.each(children, function() {
          var child = this,
              rangeId = 'range_'+child.id,
              observationsId = 'observations_'+child.id;
          if (child.range_url) {
            layers[rangeId] = po.geoJson()
              .id(rangeId)
              .url(child.range_url)
              .tile(false)
              .clip(false)
              .on('load', styling)
            map.add(layers[rangeId])
          }

          var inputId = 'taxon_check_' + child.id
          var input = $('<input type="checkbox">')
            .attr('id', inputId)
            .attr('checked', 'checked')
            .click(function() { 
              if (layers[rangeId]) { layers[rangeId].visible(this.checked); }
              layers[observationsId].visible(this.checked)
            })
          var symbol = $('<div class="symbol"></div>').css({
            backgroundColor: colorScale(child.id),
            borderColor: d3.rgb(colorScale(child.id)).darker().toString(),
            borderStyle: 'solid',
            borderWidth: '1px'
          })
          var label = $('<label></label>').attr('for', inputId).html(child.name)
          var link = $('<a></a>').attr('href', '/taxa/'+child.id).html('(view)').addClass('small')
          var li = $('<li></li>').append(input, ' ', symbol, ' ', label, ' ', link)
          $('#legend ul').append(li)
        })
        
        $.each(children, function() {
          var child = this,
              rangeId = 'range_'+child.id,
              observationsId = 'observations_'+child.id;
          layers[observationsId] = po.geoJson()
            .id(observationsId)
            .url(child.observations_url)
            .tile(false)
            .clip(false)
            .on('load', handleObservations)
            .on('load', styling)
          map.add(layers[observationsId])
        })
        
      } else  {
        if (taxonRangeUrl) {
          layers['range'] = po.geoJson()
            .id('range')
            .tile(false)
            .url(taxonRangeUrl)
          map.add(layers['range'])
        }
        addPlaces()
        addObservations()
        $('#legend li').each(function() {
          var targetLayers = $(this).attr('rel').split(' ')
          $(this).find('input').click(function() {
            for (var i = targetLayers.length - 1; i >= 0; i--){
              if (layers[targetLayers[i]]) { layers[targetLayers[i]].visible(this.checked) }
            };
          })
        })
      }
      
      map.add(po.compass())
    })
  </script>
<%- end -%>

<%- content_for(:extracss) do -%>
  <%= stylesheet_link_tag "jquery/plugins/jquery.qtip.min", "observations" %>
  <style type="text/css" media="screen">
    #map.fullscreen {background-color: white;}
    circle {
      stroke-width: 2px;
      opacity: 0.5;
      vector-effect: non-scaling-stroke;
    }
    #observations circle.confirmed {
      opacity: 1;
    }
    circle:hover {
      opacity: 1;
      cursor: pointer;
    }
    #all_observations circle {
      fill: #1E75BF;
      stroke: #074D86;
      opacity: 0.1;
    }
    #all_observations circle:hover {opacity: 1;}
    path {
      opacity: 0.5;
      fill: transparent;
      vector-effect: non-scaling-stroke;
      visibility: hidden;
    }
    path:hover {
      opacity: 0.6;
    }
    .range path { visibility: visible; }
    svg .putative {
      fill: #CA9D2C;
      stroke: #91681D;
      opacity: 0.5;
      visibility: visible;
    }
    svg .confirmed {
      fill: #84A92F;
      stroke: #55721F;
      opacity: 0.5;
      visibility: visible;
    }
    #range path {
      fill: #FF5EB0;
      stroke: deeppink;
      visibility: visible;
      opacity: 0.25;
    }
    #openspace path {
      fill: #B3C927;
      stroke: #5E6708;
      stroke-width: 1px;
      vector-effect: non-scaling-stroke;
    }
    
    #legend {
      position: absolute;
      left: 10px;
      bottom: 10px;
      z-index: 1000;
      background-color: white;
      border: 1px solid #eee;
      padding: 10px;
    }
    
    #legend .taxonimage { display: block; width: 75px; float: left; margin-right: 10px; text-align: center;}
    #legend ul { float: left; list-style: none; margin: 0;}
    #legend li { white-space: nowrap;}
    #legend .symbol { display: inline-block; vertical-align: middle; width: 16px; height: 16px; opacity: 0.5; vertical-align: middle;}
    #legend .observations .symbol, #legend .range .symbol { border: 1px solid deeppink; background-color: #FF5EB0; }
    #legend .observations .symbol {width: 5px; height: 5px; opacity: 0.5; position: relative; bottom: 2px; margin: 5px; -moz-border-raidus: 5px; -webkit-border-radius:5px; border-radius: 5px;}
    #legend .putative .symbol { border: 1px solid #91681D; background-color: #CA9D2C; }
    #legend .confirmed .symbol { border: 1px solid #55721F; background-color: #84A92F; }
    
    .compass path{visibility:visible;}
    .compass .back{fill:#eee;fill-opacity:.8;}
    .compass .fore{stroke:#999;stroke-width:1.5px;}
    .compass rect.back.fore{fill:#999;fill-opacity:.3;stroke:#eee;stroke-width:1px;shape-rendering:crispEdges;}
    .compass .direction{fill:none;}
    .compass .chevron{fill:none;stroke:#999;stroke-width:5px;}
    .compass .zoom .chevron{stroke-width:4px;}
    .compass .active .chevron,.compass .chevron.active{stroke:#fff;}
    .compass.active .active .direction{fill:#999;}

  </style>
<%- end -%>

<div id="map" class="fullscreen"></div>

<div id="legend">
  <div class="meta">
    THIS MAP IS AN EXPERIMENT!  Probably won't work in IE
  </div>
  <div class="clear stacked">
    <div class="stacked breadcrumbs">
      <%- link_to @taxon, :class => "back crumb" do %>
        Back to
        <%= render :partial => "shared/taxon", :object => @taxon, :locals => {:link => false} %>
      <% end %>
    </div>
    <%= link_to taxon_image(@taxon, :size => "square"), @taxon, :class => "taxonimage" %>
    <ul>
      <li class="putative observations" rel="observations">
        <input type="checkbox" checked="checked" id="observations_check"/>
        <div class="symbol"></div>
        <label for="observations_check">Observations (last 500)</label>
        
        <div class="confirmed">
          <input type="checkbox" checked="checked" style="visibility: hidden"/>
          <div class="symbol"></div>
          <label for="observations_check">Observations (confirmed)</label>
        </div>
      </li>
      <li class="range" rel="range">
        <input type="checkbox" checked="checked" id="range_check"/>
        <div class="symbol"></div>
        <label for="range_check">Range</label>
      </li>
      <li class="putative places" rel="countries_simple states_simple counties_simple counties">
        <input type="checkbox" checked="checked" id="places_check"/>
        <div class="symbol"></div>
        <label for="places_check">Checklist places</label>
        <div class="confirmed">
          <input type="checkbox" checked="checked" style="visibility: hidden"/>
          <div class="symbol"></div>
          <label for="places_check">Checklist places (confirmed)</label>
        </div>
      </li>
    </ul>
  </div>
  
  <div class="clear small meta">
    Only country, state, and county equivalent places shown for now. <br/>
    Zoom in to see smaller places.
  </div>
</div>
