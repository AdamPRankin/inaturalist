- content_for(:title) do
  - @title = @user ? t(:flags_on_users_content, user: @user.login) : t(:flags)
- content_for(:extrajs) do
  :javascript
    $( document ).ready( function( ) {
      $( "form #user_name" ).userAutocomplete( { idEl: $( "#user_id" ) } );
    });
- content_for :extracss do
  :css
    td.actions { min-width: 150px; }
    #user-form-group input { max-width: 100px !important; }
    #user-form-group .ac-chooser { display: inline-block; }
    .reason, .resolution { max-width: 300px; overflow: hidden; }
.container
  .row
    .col-xs-12
      %h2= @title
      %p.text-muted= t(:flags_explanation, site_name: @site.name)
  .row
    .col-xs-12
      .controls.form-inline
        = form_tag( flags_path, method: "get" ) do
          = hidden_fields_for_params( without: [:flaggable_type, :flag, :flags, :user_id, :user_name] )
          .form-group
            %label=t :content_type
            :ruby
              flaggable_type_options = options_for_select( ( ["all"] + FlagsController::FLAG_MODELS.sort ).map {|t|
                [I18n.t( t, default: t ), t]
              }, @flaggable_type )
            = select_tag :flaggable_type, flaggable_type_options, class: "select form-control"
          .form-group
            %label=t :resolved
            :ruby
              resolved_options = options_for_select( %w(any yes no).map {|t|
                [I18n.t( t, default: t ), t]
              }, @resolved )
            = select_tag :resolved, resolved_options, class: "select form-control"
          %label#user-form-group.form-group
            =t :content_author
            %input#user_name.form-control{ type: "text", name: "user_name", value: @user ? @user.login : nil, placeholder: t(:start_typing_someones_name) }
            %input#user_id.form-control{ type: "hidden", name: "user_id", value: @user ? @user.id : nil }
          %label.form-group=t :reason_label
          - [Flag::SPAM, Flag::COPYRIGHT_INFRINGEMENT, Flag::INAPPROPRIATE, "other"].each do |f|
            %label.form-group
              %input{ type: "checkbox", name: "flags[]", value: f, checked: @flag_types.include?( f ) }
              =t f
          = submit_tag t(:filter), class: "btn btn-primary"
          = link_to t(:reset), url_for, class: "btn btn-link"
  .row
    .col-xs-12
      %table.table
        %thead
          %tr
            %th=t :flagger
            %th=t :content_author
            %th=t :content_type
            %th=t :content
            %th.reason=t :reason
            %th=t :comments
            %th=t :actions
            %th.resolution=t :resolution
        %tbody
          - for flag in @flags
            - flaggable = flag.flaggable
            - flaggable_class = flaggable.class
            - flaggable = flaggable.becomes( Photo ) if flaggable.is_a?( Photo )
            %tr
              %td
                - if flag.user
                  = link_to_user(flag.user) {|| char_wrap( flag.user.login, 20 )}
                - else
                  = @site.site_name_short
              %td
                - if flag.flaggable_user
                  = link_to_user( flag.flaggable_user ) {|| char_wrap( flag.flaggable_user.login, 20 )}
                  .small.text-muted
                    = link_to t(:view_all), url_for_params( user_id: flag.flaggable_user.login, without: [:user_id] )
              %td= flaggable_class.name.humanize
              %td
                = link_to(flaggable.to_plain_s, flaggable) if flaggable.respond_to?(:to_plain_s)
                - if flaggable.respond_to?(:user) && flaggable.user
                  .small
                    = link_to_user flaggable.user, class: "text-muted" do
                      = t(:added_by_user_on_date_html, user: flaggable.user.login, date: l( flaggable.created_at) )
              %td.reason=formatted_user_text flag.flag
              %td= link_to flag.comments.count, flag, class: "badge"
              %td.actions.nobr
                .btn-group
                  = link_to flag, class: "btn btn-info btn-sm" do
                    %i.fa.fa-info
                    = t(:details)
                  = link_to flag, class: "btn btn-danger btn-sm", data: { confirm: t(:you_sure_delete_flag?) }, method: :delete do
                    %i.fa.fa-trash
                    = t(:delete)
              %td.resolution
                - if flag.resolved?
                  = formatted_user_text flag.comment
                  .text-muted=t :resolved_by_user_on_date_html, user: link_to_user( flag.resolver ), date: l( flag.resolved_at || flag.updated_at )
  .row
    .col-xs-12
      - if @flags.respond_to?(:total_pages)
        = will_paginate @flags, renderer: INatLinkRenderer

/ #flags
/   .right.inline.smallbuttons.buttonrow
/     = form_tag( flags_path, method: "get" ) do
/       = hidden_fields_for_params( without: [:user_id] )
/       = label_tag :user_id, t(:search), default: params[:user_id]
/       = text_field_tag :user_id, nil, placeholder: t(:start_typing_someones_name), data: { autosubmit: true }
/     = form_tag( flags_path, method: "get" ) do
/       = hidden_fields_for_params( without: [:flag] )
/       = select_tag :flag, options_for_select([["all", nil],
/         ["copyright infringement", :copyright_infringement],
/         ["inappropriate", :inappropriate], ["spam", :spam]], params[:flag]), data: { autosubmit: true }
/   #pageheader.column
/     %h2= @title
/   .description
/     %p= t(:flags_explanation, site_name: @site.name)
/   = render :partial => "flag_list", locals: { flags: @flags }
/   - if @flags.respond_to?(:total_pages)
/     = will_paginate @flags, renderer: INatLinkRenderer
